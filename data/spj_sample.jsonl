{"custom_id": "openr1_cf_368", "question": "You are given three positive integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$a < b < c$$$). You have to find three positive integers $$$x$$$, $$$y$$$, $$$z$$$ such that:\n\n$$$$$$x \\bmod y = a,$$$$$$ $$$$$$y \\bmod z = b,$$$$$$ $$$$$$z \\bmod x = c.$$$$$$\n\nHere $$$p \\bmod q$$$ denotes the remainder from dividing $$$p$$$ by $$$q$$$. It is possible to show that for such constraints the answer always exists.", "starter_code": "", "solutions": ["#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#pragma GCC optimization (\"-fsanitize=address\")\n#include <bits/stdc++.h>\nusing namespace std;\n/*_____________________Containers_____________________*/\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef array<int, 3> ARR;\ntypedef vector<int> VI;\ntypedef vector<double> VDB;\ntypedef vector<string> VS;\ntypedef vector<PII> VPII;\ntypedef vector<ARR> VARR;\ntypedef vector<VI> VVI;\ntypedef vector<VDB> VVDB;\ntypedef vector<VPII> VVPII;\ntypedef unordered_map<int,int> UMPII;\ntypedef map<int,int> MPII;\ntypedef set<int> SETI;\ntypedef stack<int> STI;\ntypedef queue<int> QI;\ntypedef multiset<int> MSETI;\ntypedef pair<long, long> PLL;\ntypedef vector<long> VL;\ntypedef vector<PLL> VPLL;\ntypedef vector<VL> VVL;\ntypedef vector<VARR> VVARR;\ntypedef map<long, long> MPLL;\ntypedef set<long> SETL;\ntypedef queue<long> QL;\ntypedef multiset<long> MSETL;\ntypedef pair<ll, ll> PLLLL;\ntypedef vector<ll> VLL;\ntypedef vector<PLLLL> VPLLLL;\ntypedef vector<VLL> VVLL;\ntypedef map<ll, ll> MPLLLL;\ntypedef set<ll> SETLL;\ntypedef queue<ll> QLL;\ntypedef multiset<ll> MSETLL;\n/*__________________________________________________________*/\n/*____________________Limits & Constants____________________*/\nconstexpr int inf = 0x3f3f3f3f;\nconstexpr ll INF = 0x3F3F3F3F3F3F3F3F;\n/*_______________________________________________________________*/\n/*_____________________________Macros____________________________*/\n#define MOD int(998244353)\n#define PI (2 * acos(0.0))\n#define ff(i, j, k) for(ll i = j; i < k; i++)\n#define FF(i, j, k) for(ll i = j; i >= k; i--)\n#define mem(a,n) memset(a, n, sizeof(a) )\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) (a*(b/gcd(a,b)))\n#define spc(n) setprecision(n)\n#define sz(x) int(x.size())\n#define pb push_back\n#define eb emplace_back\n#define mk(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define bit_popcount __builtin_popcount\n#define bit_ctz __builtin_ctz\n#define bit_clz __builtin_clz\n#define bit_popcountll __builtin_popcountll\n#define bit_ctzll __builtin_ctzll\n#define bit_clzll __builtin_clzll\n#define csor(a,compare) sort(a.begin(),a.end(),compare)\n#define asor(a) sort(a.begin(),a.end())\n#define dsor(a) sort(a.rbegin(),a.rend())\n#define mxe(v) *max_element(v.begin(), v.end())\nint ask(const string &s) { int r; return cout << \"? \" << s <<endl, cin >> r, r; }\n/*________________________________________________________________*/\n/*___________________________printf out___________________________*/\n#ifndef ONLINE_JUDGE\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { (void)scanf(\"%d\", &x); }\nvoid _R(ll &x) { (void)scanf(\"%lld\", &x); }\nvoid _R(double &x) { (void)scanf(\"%lf\", &x); }\nvoid _R(char &x) { (void)scanf(\" %c\", &x); }\nvoid _R(char *x) { (void)scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const ll &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.fi); putchar(' '); _W(x.se); putchar('\\n'); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) putchar(\" \\n\"[i == x.cbegin()]); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#endif\n/*_______________________________________________________________*/\n/*_________________Combinations number___________________________*/\nconst int Combinations_N = 400005;\nll fact[Combinations_N];\nll mult(ll a,ll b) {\n    return ((a % MOD)*(b % MOD)) % MOD;\n}\nll add(ll a,ll b) {\n    return ((a % MOD)+(b % MOD)) % MOD;\n}\nll subt(ll a,ll b) {\n    ll ans = ((a % MOD) - (b % MOD)) % MOD;\n    ans %= MOD;\n    ans = (ans + MOD) % MOD;\n    return ans;\n}\n\nll exp(ll a, ll b) {\n    ll ans = 1;\n    ll po = a;\n    while (b != 0){\n        if(b % 2){\n            ans = ((ans % MOD) * (po % MOD)) % MOD;\n        }\n        po = ((po % MOD) * (po % MOD)) % MOD;\n        b /= 2;\n    }\n    return ans;\n}        \nll inv(ll x) {\n\treturn exp(x, MOD - 2); // \u516c\u5f0f\uff1a1 / B = B ^ (MOD - 2)\n}\nll divide(ll x, ll y) {\n\treturn mult(x, inv(y));\n}\nvoid factorial(void) {\n\tfact[0] = 1;\n\tfor(int i = 1; i < Combinations_N; i++)\n\t\tfact[i] = mult(i, fact[i - 1]);\n}\n// Cm n = C(n-m) n\n// Cm (n+1) = Cm n + C(m-1) n\n// \u03a3k i=0 Cn (n+i) = C(n+1) (n+k+1)\nll C(ll n, ll k) {\n\tif(k > n) return 0;\n\treturn divide(fact[n], mult(fact[n - k], fact[k]));\n}\n\n/*_______________________________________________________________*/\n/*______________________Carmichael Numbers_______________________*/\nll Pow(ll a, ll n) {\n    if (n == 0) return 0;\n    if (n == 1) return a;\n    ll c = Pow(a, n / 2) % MOD;\n    if (n % 2 == 0) return (c % MOD) * (c % MOD) % MOD;\n    return (c % MOD) * (c % MOD) * (a % MOD)% MOD;\n}\n\n/*_______________________________________________________________*/\n/*___________________________Modular_____________________________*/\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n \ntemplate <typename T>\nclass Modular {\n    public:\n    using Type = typename decay<decltype(T::value)>::type;\n    \n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n    \n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n    \n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n    \n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n    \n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n    \n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n    \n    friend const Type& abs(const Modular& x) { return x.value; }\n    \n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n    \n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n    \n    template <typename V, typename U>\n    friend V& operator>>(V& stream, Modular<U>& number);\n    \nprivate:\n    Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n \n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n    return stream << number();\n}\n \n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, long long>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& MOD = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nusing Mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\ntypedef vector<Mint> VMint;\ntypedef vector<VMint> VVMint;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int) fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\n/*_______________________________________________________________*/\n/*_________________________segment tree__________________________*/\n/*______________________\u6743\u503c\u7ebf\u6bb5\u6811\u53ef\u53c2\u80031705E_____________________*/\nclass segtree {\n    public:\n    struct node {\n        ll mn = -1;\n        ll mx = -1;\n        // ll val = 0;\n        // ll sum_v = 0;\n        ll add = 0;\n        ll sum_a = 0;\n        ll idx;\n \n        void apply(int l, int r, ll v) {\n            mn = mx = v;\n            // val = v;\n            // sum_v = (ll)v * (r - l + 1);\n            add += v;\n            sum_a += (ll)v * (r - l + 1);\n            idx = l;\n        }\n    };\n\n    node unite(const node &a, const node &b) const {\n        node res;\n        res.mn = min(a.mn, b.mn);\n        res.mx = max(a.mx, b.mx);\n        // res.sum_v = a.sum_v + b.sum_v;\n        res.sum_a = a.sum_a + b.sum_a;\n        if (a.mx > b.mx) res.idx = a.idx;\n        else res.idx = b.idx;\n        return res;\n    }\n \n    inline void push(int x, int l, int r) {\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        // if (tree[x].val != 0) {\n        //     tree[x + 1].apply(l, y, tree[x].val);\n        //     tree[z].apply(y + 1, r, tree[x].val);\n        //     tree[x].val = 0;\n        // }\n        if (tree[x].add != 0) {\n            tree[x + 1].apply(l, y, tree[x].add);\n            tree[z].apply(y + 1, r, tree[x].add);\n            tree[x].add = 0;\n        }\n    }\n    \n    inline void pull(int x, int z) {\n        tree[x] = unite(tree[x + 1], tree[z]);\n    }\n    \n    int n;\n    vector<node> tree;\n    \n    void build(int x, int l, int r) {\n        if (l == r) {\n            return;\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        build(x + 1, l, y);\n        build(z, y + 1, r);\n        pull(x, z);\n    }\n    \n    template <typename M>\n    void build(int x, int l, int r, const vector<M> &v) {\n        if (l == r) {\n            tree[x].apply(l, r, v[l]);\n            return;\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        build(x + 1, l, y, v);\n        build(z, y + 1, r, v);\n        pull(x, z);\n    }\n    \n    node get(int x, int l, int r, int ll, int rr) {\n        if (ll <= l && r <= rr) {\n            return tree[x];\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        push(x, l, r);\n        node res{};\n        if (rr <= y) {\n            res = get(x + 1, l, y, ll, rr);\n        } else {\n            if (ll > y) {\n                res = get(z, y + 1, r, ll, rr);\n            } else {\n                res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n            }\n        }\n        pull(x, z);\n        return res;\n    }\n    \n    template <typename... M>\n    void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n        if (ll <= l && r <= rr) {\n            tree[x].apply(l, r, v...);\n            return;\n        }\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        push(x, l, r);\n        if (ll <= y) {\n            modify(x + 1, l, y, ll, rr, v...);\n        }\n        if (rr > y) {\n            modify(z, y + 1, r, ll, rr, v...);\n        }\n        pull(x, z);\n    }\n    \n    int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n        if (l == r) {\n            return l;\n        }\n        push(x, l, r);\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        int res;\n        if (f(tree[x + 1])) {\n            res = find_first_knowingly(x + 1, l, y, f);\n        } else {\n            res = find_first_knowingly(z, y + 1, r, f);\n        }\n        pull(x, z);\n        return res;\n    }\n    \n    int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n        if (ll <= l && r <= rr) {\n            if (!f(tree[x])) {\n                return -1;\n            }\n            return find_first_knowingly(x, l, r, f);\n        }\n        push(x, l, r);\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        int res = -1;\n        if (ll <= y) {\n            res = find_first(x + 1, l, y, ll, rr, f);\n        }\n        if (rr > y && res == -1) {\n            res = find_first(z, y + 1, r, ll, rr, f);\n        }\n        pull(x, z);\n        return res;\n    }\n    \n    int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n        if (l == r) {\n            return l;\n        }\n        push(x, l, r);\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        int res;\n        if (f(tree[z])) {\n            res = find_last_knowingly(z, y + 1, r, f);\n        } else {\n            res = find_last_knowingly(x + 1, l, y, f);\n        }\n        pull(x, z);\n        return res;\n    }\n    \n    int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n        if (ll <= l && r <= rr) {\n            if (!f(tree[x])) {\n                return -1;\n            }\n            return find_last_knowingly(x, l, r, f);\n        }\n        push(x, l, r);\n        int y = (l + r) >> 1;\n        int z = x + ((y - l + 1) << 1);\n        int res = -1;\n        if (rr > y) {\n            res = find_last(z, y + 1, r, ll, rr, f);\n        }\n        if (ll <= y && res == -1) {\n            res = find_last(x + 1, l, y, ll, rr, f);\n        }\n        pull(x, z);\n        return res;\n    }\n    \n    segtree(int _n) : n(_n) {\n        assert(n > 0);\n        tree.resize(2 * n - 1);\n        build(0, 0, n - 1);\n    }\n    \n    template <typename M>\n    segtree(const vector<M> &v) {\n        n = v.size();\n        assert(n > 0);\n        tree.resize(2 * n - 1);\n        build(0, 0, n - 1, v);\n    }\n    \n    node get(int ll, int rr) {\n        assert(0 <= ll);\n        assert(ll <= rr);\n        assert(rr <= n - 1);\n        return get(0, 0, n - 1, ll, rr);\n    }\n    \n    node get(int p) {\n        assert(0 <= p && p <= n - 1);\n        return get(0, 0, n - 1, p, p);\n    }\n    \n    template <typename... M>\n    void modify(int ll, int rr, const M&... v) {\n        assert(0 <= ll);\n        assert(ll <= rr);\n        assert(rr <= n - 1);\n        modify(0, 0, n - 1, ll, rr, v...);\n    }\n    \n    // find_first and find_last call all FALSE elements\n    // to the left (right) of the sought position exactly once\n    \n    int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n        assert(0 <= ll);\n        assert(ll <= rr);\n        assert(rr <= n - 1);\n        return find_first(0, 0, n - 1, ll, rr, f);\n    }\n    \n    int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n        assert(0 <= ll);\n        assert(ll <= rr);\n        assert(rr <= n - 1);\n        return find_last(0, 0, n - 1, ll, rr, f);\n    }\n};\n\n/*_______________________________________________________________*/\n/*______________________Disjoint Set Union_______________________*/\nclass dsu {\n    public:\n    VI p;\n    VLL ml;\n    VLL mr;\n    VLL mx;\n    VLL s;\n    int n;\n\n    dsu (int _n) : n(_n) {\n        assert(n > 0);\n        p.resize(n + 1);\n        iota(p.begin(), p.end(), 0);\n        ml.resize(n + 1);\n        iota(ml.begin(), ml.end(), 0);\n        mr.resize(n + 1);\n        iota(mr.begin(), mr.end(), 0);\n        mx.resize(n + 1);\n        iota(mx.begin(), mx.end(), 0);\n        s.resize(n + 1);\n        iota(s.begin(), s.end(), 0);\n    }\n\n    template <typename M>\n    dsu (const vector<M> &v) {\n        n = v.size();\n        assert(n > 0);\n        p.resize(n + 1);\n        iota(p.begin(), p.end(), 0);\n        ml.resize(n + 1);\n        mr.resize(n + 1);\n        mx.resize(n + 1);\n        s.resize(n + 1);\n        ff (i, 1, n + 1) {\n            ml[i] = mr[i] = mx[i] = s[i] = v[i];\n        }\n    }\n    \n    inline int find (int x) {\n        return (x == p[x] ? x : (p[x] = find(p[x])));\n    }\n    \n    inline bool unite (int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        p[x] = y;\n        mx[y] = max({mx[x], mx[y], max(0LL, mr[x]) + ml[y], mr[x] + max(0LL, ml[y])});\n        mr[y] = max(mr[y], max(0LL, mr[x]) + s[y]);\n        ml[y] = max(ml[x], max(0LL, ml[y]) + s[x]);\n        s[y] += s[x];\n        return true;\n    }\n};\n\n/*_______________________________________________________________*/\n/*_________________________Sparse Table__________________________*/\n/*__________________________\u53ef\u53c2\u80031691D___________________________*/\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n    public:\n    int n;\n    vector<vector<T>> mat;\n    F func;\n    \n    SparseTable(const vector<T>& a, const F& f) : func(f) {\n        n = static_cast<int>(a.size());\n        int max_log = 32 - __builtin_clz(n);\n        mat.resize(max_log);\n        mat[0] = a;\n        for (int j = 1; j < max_log; j++) {\n            mat[j].resize(n - (1 << j) + 1);\n            for (int i = 0; i <= n - (1 << j); i++) {\n                mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n            }\n        }\n    }\n    \n    T get(int from, int to) const {\n        assert(0 <= from && from <= to && to <= n - 1);\n        int lg = 32 - __builtin_clz(to - from + 1) - 1;\n        return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n    }\n};\n\n/*_______________________________________________________________*/\n/*____________________________Graph______________________________*/\ntemplate <typename T>\nclass graph {\n    public:\n    struct edge {\n        int from;\n        int to;\n        T cost;\n    };\n    \n    vector<edge> edges;\n    vector<vector<int>> g;\n    int n;\n    \n    graph(int _n) : n(_n) {\n        g.resize(n);\n    }\n    \n    virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n    public:\n    using graph<T>::edges;\n    using graph<T>::g;\n    using graph<T>::n;\n\n    digraph(int _n) : graph<T>(_n) {\n    }\n\n    int add(int from, int to, T cost = 1) {\n        assert(0 <= from && from < n && 0 <= to && to < n);\n        int id = (int) edges.size();\n        g[from].push_back(id);\n        edges.push_back({from, to, cost});\n        return id;\n    }\n\n    digraph<T> reverse() const {\n        digraph<T> rev(n);\n        for (auto &e : edges) {\n        rev.add(e.to, e.from, e.cost);\n        }\n        return rev;\n    }\n};\n    \ntemplate <typename T>\nclass forest : public graph<T> {\n    public:\n    using graph<T>::edges;\n    using graph<T>::g;\n    using graph<T>::n;\n    \n    forest(int _n) : graph<T>(_n) {\n    }\n    \n    int add(int from, int to, T cost = 1) {\n        assert(0 <= from && from < n && 0 <= to && to < n);\n        int id = (int)edges.size();\n        assert(id < n - 1);\n        g[from].push_back(id);\n        g[to].push_back(id);\n        edges.push_back({from, to, cost});\n        return id;\n    }\n};\n    \ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n    public:\n    using forest<T>::edges;\n    using forest<T>::g;\n    using forest<T>::n;\n    \n    vector<int> pv;\n    vector<int> pe;\n    vector<int> order;\n    vector<int> pos;\n    vector<int> end;\n    vector<int> sz;\n    vector<int> root;\n    vector<int> depth;\n    vector<T> dist;\n    \n    dfs_forest(int _n) : forest<T>(_n) {\n    }\n    \n    void init() {\n        pv = vector<int>(n, -1);\n        pe = vector<int>(n, -1);\n        order.clear();\n        pos = vector<int>(n, -1);\n        end = vector<int>(n, -1);\n        sz = vector<int>(n, 0);\n        root = vector<int>(n, -1);\n        depth = vector<int>(n, -1);\n        dist = vector<T>(n);\n    }\n    \n    void clear() {\n        pv.clear();\n        pe.clear();\n        order.clear();\n        pos.clear();\n        end.clear();\n        sz.clear();\n        root.clear();\n        depth.clear();\n        dist.clear();\n    }\n\n    private:\n    void do_dfs(int v) {\n        pos[v] = (int) order.size();\n        order.push_back(v);\n        sz[v] = 1;\n        for (int id : g[v]) {\n            if (id == pe[v]) {\n                continue;\n            }\n            auto &e = edges[id];\n            int to = e.from ^ e.to ^ v;\n            depth[to] = depth[v] + 1;\n            dist[to] = dist[v] + e.cost;\n            pv[to] = v;\n            pe[to] = id;\n            root[to] = (root[v] != -1 ? root[v] : to);\n            do_dfs(to);\n            sz[v] += sz[to];\n        }\n        end[v] = (int) order.size() - 1;\n    }\n    \n    void do_dfs_from(int v) {\n        depth[v] = 0;\n        dist[v] = T{};\n        root[v] = v;\n        pv[v] = pe[v] = -1;\n        do_dfs(v);\n    }\n    \n    public:\n    void dfs(int v, bool clear_order = true) {\n        if (pv.empty()) {\n            init();\n        } else {\n            if (clear_order) {\n                order.clear();\n            }\n        }\n        do_dfs_from(v);\n    }\n    \n    void dfs_all() {\n        init();\n        for (int v = 0; v < n; v++) {\n            if (depth[v] == -1) {\n                do_dfs_from(v);\n            }\n        }\n        assert((int) order.size() == n);\n    }\n};\n    \ntemplate <typename T>\nclass lca_forest : public dfs_forest<T> {\n    public:\n    using dfs_forest<T>::edges;\n    using dfs_forest<T>::g;\n    using dfs_forest<T>::n;\n    using dfs_forest<T>::pv;\n    using dfs_forest<T>::pos;\n    using dfs_forest<T>::end;\n    using dfs_forest<T>::depth;\n    \n    int h;\n    vector<vector<int>> pr;\n    \n    lca_forest(int _n) : dfs_forest<T>(_n) {\n    }\n    \n    inline void build_lca() {\n        assert(!pv.empty());\n        int max_depth = 0;\n        for (int i = 0; i < n; i++) {\n            max_depth = max(max_depth, depth[i]);\n        }\n        h = 1;\n        while ((1 << h) <= max_depth) {\n            h++;\n        }\n        pr.resize(n);\n        for (int i = 0; i < n; i++) {\n            pr[i].resize(h);\n            pr[i][0] = pv[i];\n        }\n        for (int j = 1; j < h; j++) {\n            for (int i = 0; i < n; i++) {\n                pr[i][j] = (pr[i][j - 1] == -1 ? -1 : pr[pr[i][j - 1]][j - 1]);\n            }\n        }\n    }\n    \n    inline bool anc(int x, int y) {\n        return (pos[x] <= pos[y] && end[y] <= end[x]);\n    }\n    \n    inline int go_up(int x, int up) {\n        assert(!pr.empty());\n        up = min(up, (1 << h) - 1);\n        for (int j = h - 1; j >= 0; j--) {\n            if (up & (1 << j)) {\n                x = pr[x][j];\n                if (x == -1) {\n                break;\n                }\n            }\n        }\n        return x;\n    }\n    \n    inline int lca(int x, int y) {\n        assert(!pr.empty());\n        if (anc(x, y)) {\n            return x;\n        }\n        if (anc(y, x)) {\n            return y;\n        }\n        for (int j = h - 1; j >= 0; j--) {\n            if (pr[x][j] != -1 && !anc(pr[x][j], y)) {\n                x = pr[x][j];\n            }\n        }\n        return pr[x][0];\n    }\n};\n\n/*_______________________________________________________________*/\n/*_______________________Topological Sort________________________*/\ntemplate <typename T>\nvector<int> find_topsort(const digraph<T> &g) {\n    vector<int> deg(g.n, 0);\n    for (int id = 0; id < (int) g.edges.size(); id++) {\n        deg[g.edges[id].to]++;\n    }\n    vector<int> x;\n    for (int i = 0; i < g.n; i++) {\n        if (deg[i] == 0) {\n            x.push_back(i);\n        }\n    }\n    for (int ptr = 0; ptr < (int) x.size(); ptr++) {\n        int i = x[ptr];\n        for (int id : g.g[i]) {\n            auto &e = g.edges[id];\n            int to = e.to;\n            if (--deg[to] == 0) {\n                x.push_back(to);\n            }\n        }\n    }\n    if ((int) x.size() != g.n) {\n        return vector<int>();\n    }\n    return x;\n}\n\n/*_______________________________________________________________*/\n/*______________________________SCC______________________________*/\n\n\n\nvoid init_code() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    // \u672c\u5730\u8c03\u8bd5\u4ea4\u4e92\u5f0f\u9898\u76ee\u53ef\u53c2\u80031705F\n#ifndef ONLINE_JUDGE\n\n#else\n\n#endif\n}\n/*\n * \u6c42\u6700\u957f\u4e25\u683c\u9012\u589e\u5b50\u5e8f\u5217\u957f\u5ea6\n */\nint LIS(VL v) {\n    int n = v.size();\n    VI dp(n);\n    dp[0] = 1;\n    int ans = 0;\n    ff (i, 1, n) {\n        int cnt = 1;\n        FF (j, i - 1, 0) {\n            if (v[i] > v[j]) {\n                cnt = max(cnt, dp[j] + 1);\n            }\n        }\n        dp[i] = cnt;\n    }\n    ff (i, 0, n) {\n        ans = max(ans, dp[i]);\n    }\n    return ans;\n}\n\n/*\n *\n */\nvoid solve() {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    cout << (a + b * c) << \" \" << b << \" \" << c << endl;\n}\n\n/*_______________________________________________________________*/\nsigned main()\n{\n    init_code();\n\tll t = 1;\n    cin >> t;\n    cout << spc(20) << endl;\n\twhile(t--){\n        solve();\n\t}\n}", "#include <iostream>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <algorithm>\n\n#include <cmath>\n\n#include <map>\n\n#define ll long long\n\n#define N 200010\n\nusing namespace std;\n\nll read(){\n\n\tchar cc;\n\n\twhile(1){cc=getchar();if((cc>='0'&&cc<='9')||cc=='-')break;}\n\n\tll sum=0,flag=1;\n\n\tcc=='-'?flag=-1:sum=(cc^48);\n\n\twhile(1){cc=getchar();if(!(cc>='0'&&cc<='9'))break;sum=(sum<<1)+(sum<<3)+(cc^48);}\n\n\treturn sum*flag;\n\n}\n\nvoid write(ll x){\n\n\tif(!x)putchar('0');\n\n\tif(x<0){x=-x;putchar('-');}\n\n\tll cc[25],cntt=0;\n\n\twhile(x){cc[++cntt]=x%10;x/=10;}\n\n\tfor(ll i=cntt;i>=1;i--)putchar(cc[i]+'0');\n\n\tputchar('\\n');\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nll t,a,b,c;\n\n\n\nint main(){\n\n\tcin>>t;\n\n\twhile(t--){cin>>a>>b>>c;\n\n\tcout<<(c+1)*a+b<<\" \"<<c*a+b<<\" \"<<c<<endl;\n\n\t}\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\t\n\n\treturn 0;\n\n} \n\n/*\n\n\n\n\n\n*/", "#include <iostream>\n\n#include <map>\n\n#include <climits>\n\n#include <math.h>\n\n#include <vector>\n\n#include <string>\n\n#include <queue>\n\n#include <algorithm>\n\nusing namespace std;\n\n\n\n#define ll long long\n\n#define ull unsigned long long\n\n\n\n#define forc(n) for(int i = 0; i < n; ++i)\n\n#define ford(n) for(int i = 1; i <= n; ++i)\n\n\n\n#define ajutor ios_base::sync_with_stdio(false);\n\n#define pls cin.tie(nullptr); cout.tie(nullptr)\n\n\n\nvoid solve()\n\n{\n\n    int a,b,c;cin>>a>>b>>c;\n\n\n\n    cout<<a+b+c<<\" \"<<b+c<<\" \"<<c<<'\\n';\n\n}\n\n\n\nint main()\n\n{\n\n    ajutor pls;\n\n    int tt=1;\n\n    cin >> tt;\n\n\n\n    while(tt--)\n\n        solve();\n\n}", "#define _USE_MATH_DEFINES\n\n#include <bits/stdc++.h>\n\n#define all(X) X.begin(), X.end()\n\n#define rall(X) X.rbegin(), X.rend()\n\n#define minim(X) min_element(all(X))\n\n#define maxim(X) max_element(all(X))\n\n#define ssort(X) stable_sort(all(X))\n\n#define rever(X) reverse(all(X))\n\n#define fi first\n\n#define se second\n\n#define gcd __gcd\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nconst ld Pi = M_PI;\n\n\n\nvoid solve()\n\n{\n\n    int a, b, c;\n\n    cin >> a >> b >> c;\n\n    cout << a + b + c << ' ' << b + c << ' ' << c << '\\n';\n\n    return;\n\n}\n\n\n\nint main()\n\n{\n\n    ios::sync_with_stdio(0);\n\n    cin.tie(0); cout.tie(0);\n\n    int t;\n\n    cin >> t;\n\n    while (t--)\n\n        solve();\n\n    return 0;\n\n}\n\n\n\n/**\n\n    cout << fixed << setprecision(10);\n\n    ios::sync_with_stdio(0);\n\n    cin.tie(0); cout.tie(0);\n\n    int t;\n\n    cin >> t;\n\n    while (t--)\n\n        solve();\n\ncout << solve() << '\\n';\n\ncout << (solve() ? \"YES\" : \"NO\") << '\\n';\n\n**/", "#include <bits/stdc++.h>\n\n\n\n#include <ext/pb_ds/assoc_container.hpp>\n\n#include <ext/pb_ds/tree_policy.hpp>\n\n\n\nusing namespace std;\n\nusing namespace __gnu_pbds;\n\n\n\ntypedef long long ll;\n\ntypedef vector<int> vi;\n\ntypedef vector<int>::iterator vit;\n\ntypedef vector<vector<int>> vii;\n\ntypedef pair<int, int> pii;\n\ntypedef tuple<int, int, int> tiii;\n\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\n\n\n#define REP(i, a, b) for (int i = a; i < b; i++)\n\n#define REPP(i, a, b) for (int i = a; i >= b; i--)\n\n#define PB push_back\n\n#define MP make_pair\n\n#define MT make_tuple\n\n#define F first\n\n#define S second\n\n#define sq(a) ((a) * (a))\n\n#define v(t) vector<t>\n\n#define all(v) v.begin(), v.end()\n\n\n\n#define duration(a) std::chrono::duration_cast<std::chrono::milliseconds>(a).count()\n\n#define timeNow() std::chrono::high_resolution_clock::now()\n\n\n\nvoid run()\n\n{\n\n    ll a, b, c; cin >> a >> b >> c;\n\n    cout << c + a + b << ' ' << c + b << ' ' << c << '\\n';\n\n}\n\n\n\nint main()\n\n{\n\n    cin.tie(NULL);\n\n    ios_base::sync_with_stdio(false);\n\n\n\n#ifndef ONLINE_JUDGE\n\n    freopen(\"temp/input.txt\", \"r\", stdin);\n\n    freopen(\"temp/output.txt\", \"w\", stdout);\n\n#endif\n\n\n\n    int t = 1;\n\n    cin >> t;\n\n    REP(i, 1, t + 1) {\n\n        // cout << \"Case #\" << i << \": \";\n\n        run();\n\n        // cout << '\\n';\n\n    }\n\n}"], "input_generator": ["import random\n\ndef generate_single_case():\n    while True:\n        # \u751f\u6210b\u7684\u503c\uff0c\u786e\u4fddc = b*k\u4e0d\u8d85\u8fc71e8\n        b = random.randint(2, 10**8 // 2)\n        max_k = 10**8 // b\n        if max_k < 2:  # \u786e\u4fdd\u81f3\u5c11\u6709k>=2\n            continue\n        k = random.randint(2, max_k)\n        c = b * k\n        \n        # \u751f\u6210a\u7684\u503c\uff0c\u786e\u4fdd1 <= a < b\n        a = random.randint(1, b-1)\n        \n        if a < b < c:\n            return (a, b, c)\n\ndef generate_test_inputs(num_cases=100):\n    random.seed(42)\n    test_case_list = []\n    for _ in range(num_cases):\n        # \u63a7\u5236\u6d4b\u8bd5\u7528\u4f8b\u6570\u91cft\uff0c\u9632\u6b62\u8fc7\u5927\u8f93\u5165\n        t = random.randint(1, 100)\n        cases = []\n        for __ in range(t):\n            a, b, c = generate_single_case()\n            cases.append(f\"{a} {b} {c}\")\n        input_str = f\"{t}\\n\" + \"\\n\".join(cases)\n        test_case_list.append(input_str)\n    return test_case_list\n\ndef main():\n    test_cases = generate_test_inputs()\n    print(test_cases)\n\nif __name__ == \"__main__\":\n    main()\n", "import random\n\ndef generate_single_case():\n    while True:\n        # \u751f\u6210\u7b56\u7565\uff1a\u4f18\u5148\u4fdd\u8bc1c\u662fb\u7684\u500d\u6570\n        b = random.choice([\n            random.randint(2, 100),        # \u5c0fb\n            random.randint(101, 10**4),    # \u4e2db\n            random.randint(10**4+1, 5*10**7)  # \u5927b\uff08\u786e\u4fddk\u22652\u65f6c\u22641e8\uff09\n        ])\n        \n        # \u8ba1\u7b97\u6700\u5927\u500d\u6570k\n        max_k = (10**8) // b\n        if max_k < 2:  # \u786e\u4fdd\u81f3\u5c11\u80fd\u53d6k=2\n            continue\n        \n        # \u751f\u6210k\u503c\uff0880%\u6982\u7387\u53d6\u5c0fk\uff0c20%\u5927k\uff09\n        if random.random() < 0.8:\n            k = random.randint(2, min(10, max_k))\n        else:\n            k = random.randint(2, max_k)\n        \n        c = b * k\n        \n        # \u751f\u6210a\uff08\u591a\u6837\u5316\u7b56\u7565\uff09\n        if b == 2:  # \u8fb9\u754c\u5904\u7406\n            a = 1\n        elif random.random() < 0.7:  # 70%\u6982\u7387a\u8fdc\u5c0f\u4e8eb\n            a = random.randint(1, max(1, b//100))\n        else:  # 30%\u6982\u7387a\u63a5\u8fd1b\n            a = random.randint(max(1, b - 10), b-1)\n        \n        if a < b < c:\n            return (a, b, c)\n\ndef generate_test_inputs(num_cases=100):\n    random.seed(42)\n    test_case_list = []\n    \n    # \u5f3a\u5236\u6dfb\u52a0\u5173\u952e\u8fb9\u754c\u7528\u4f8b\n    boundaries = [\n        (1, 2, 4),          # \u6700\u5c0f\u53ef\u80fd\u7528\u4f8b\n        (1, 2, 100000000),  # \u6700\u5927\u500d\u6570\u7528\u4f8b\n        (99999999, 50000000, 100000000)  # \u5927\u6570\u7528\u4f8b\n    ]\n    for a, b, c in boundaries:\n        test_case_list.append(f\"1\\n{a} {b} {c}\")\n    \n    # \u751f\u6210\u968f\u673a\u7528\u4f8b\n    for _ in range(num_cases - len(boundaries)):\n        t = random.choices(\n            [1, 5, 50, 100], \n            weights=[0.2, 0.3, 0.3, 0.2], \n            k=1\n        )[0]\n        \n        cases = []\n        for __ in range(t):\n            a, b, c = generate_single_case()\n            cases.append(f\"{a} {b} {c}\")\n        \n        input_str = f\"{t}\\n\" + \"\\n\".join(cases)\n        test_case_list.append(input_str)\n    \n    return test_case_list[:num_cases]\n\ndef main():\n    test_cases = generate_test_inputs()\n    print(test_cases)\n\nif __name__ == \"__main__\":\n    main()\n", "import random\n\ndef generate_single_case():\n    while True:\n        # \u9996\u5148\u751f\u6210a\u548cb\uff0c\u786e\u4fdda < b\n        a = random.randint(1, 50000)\n        b = random.randint(a + 1, 100000)\n        \n        # \u8ba1\u7b97c\u7684\u4e0a\u9650\uff1a\u5fc5\u987b\u6ee1\u8db3c < a + b\n        max_c = a + b - 1\n        if max_c <= b:  # \u65e0\u6cd5\u751f\u6210\u6709\u6548c\u65f6\u91cd\u65b0\u751f\u6210\n            continue\n        \n        # \u751f\u6210c\u7684\u8303\u56f4\u4e3a(b, a + b - 1)\n        c = random.randint(b + 1, max_c)\n        \n        # \u9a8c\u8bc1\u6761\u4ef6\n        if a < b < c:\n            return (a, b, c)\n\ndef generate_test_inputs(num_cases=100):\n    random.seed(42)\n    test_case_list = []\n    \n    for _ in range(num_cases):\n        # \u63a7\u5236\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u89c4\u6a21\n        t = random.choices([1, 10, 100], weights=[0.1, 0.6, 0.3], k=1)[0]\n        \n        cases = []\n        for __ in range(t):\n            a, b, c = generate_single_case()\n            cases.append(f\"{a} {b} {c}\")\n        \n        # \u6784\u5efa\u5b8c\u6574\u8f93\u5165\n        input_str = f\"{t}\\n\" + \"\\n\".join(cases)\n        test_case_list.append(input_str)\n    \n    # \u6dfb\u52a0\u8fb9\u754c\u6d4b\u8bd5\u7528\u4f8b\uff08\u786e\u4fdd\u7b26\u5408\u65b0\u7684\u751f\u6210\u89c4\u5219\uff09\n    boundary_cases = [\n        \"1\\n2 3 4\",    # a=2, b=3, c=4 (c=4 < 2+3=5)\n        \"1\\n5 6 10\",   # a=5, b=6, c=10 (10 < 5+6=11)\n        \"1\\n3 4 6\",    # a=3, b=4, c=6 (6 < 3+4=7)\n    ]\n    test_case_list[-len(boundary_cases):] = boundary_cases\n    \n    return test_case_list[:num_cases]\n\ndef main():\n    test_cases = generate_test_inputs()\n    print(test_cases)\n\nif __name__ == \"__main__\":\n    main()\n", "import random\n\ndef generate_single_case():\n    while True:\n        # \u751f\u6210a\u548cb\uff0c\u786e\u4fdda + b + 1 <= 1e8\n        a = random.randint(1, 10**8 - 3)\n        max_b = min(10**8 - 1, 10**8 - a - 1)\n        if max_b <= a:\n            continue  # \u65e0\u6cd5\u751f\u6210\u6709\u6548\u7684b\n        b = random.randint(a + 1, max_b)\n        \n        # \u786e\u5b9ac\u7684\u6700\u5c0f\u503c\n        min_c = a + b + 1\n        if min_c > 10**8:\n            continue\n        \n        # \u751f\u6210c\u7684\u7b56\u7565\uff1a\u5c0f\u3001\u4e2d\u3001\u5927\u6570\u503c\n        rand_type = random.random()\n        if rand_type < 0.3:\n            c = random.randint(min_c, min(min_c + 100, 10**8))\n        elif rand_type < 0.6:\n            c = random.randint(min_c, min(min_c + 10000, 10**8))\n        else:\n            lower = max(min_c, 10**8 - 100)\n            c = random.randint(lower, 10**8)\n        \n        # \u6700\u7ec8\u9a8c\u8bc1\u6761\u4ef6\n        if a < b < c and c >= min_c:\n            return (a, b, c)\n\ndef generate_test_inputs(num_cases=100):\n    random.seed(42)\n    test_case_list = []\n    for _ in range(num_cases):\n        t = random.randint(1, 100)  # \u63a7\u5236\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u6848\u4f8b\u6570\n        cases = []\n        for __ in range(t):\n            a, b, c = generate_single_case()\n            cases.append(f\"{a} {b} {c}\")\n        input_str = f\"{t}\\n\" + \"\\n\".join(cases)\n        test_case_list.append(input_str)\n    return test_case_list\n\ndef main():\n    test_cases = generate_test_inputs()\n    print(test_cases)\n\nif __name__ == \"__main__\":\n    main()\n"], "checker": ["import sys\n\ndef is_valid_output(input_str, output_str, reference_output_str):\n    try:\n        # \u89e3\u6790\u8f93\u5165\u548c\u8f93\u51fa\n        input_lines = input_str.strip().splitlines()\n        t = int(input_lines[0])\n        test_cases = [list(map(int, line.split())) for line in input_lines[1:]]\n        user_outputs = [list(map(int, line.split())) for line in output_str.strip().splitlines()]\n        \n        # \u68c0\u67e5\u884c\u6570\u662f\u5426\u5339\u914d\n        if len(user_outputs) != t:\n            return False\n            \n        # \u9a8c\u8bc1\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\n        for (a, b, c), (x, y, z) in zip(test_cases, user_outputs):\n            # \u68c0\u67e5\u8303\u56f4\u7ea6\u675f\n            if not (1 <= x <= 10**18 and 1 <= y <= 10**18 and 1 <= z <= 10**18):\n                return False\n            # \u68c0\u67e5\u4e09\u4e2a\u53d6\u6a21\u6761\u4ef6\n            if (x % y != a) or (y % z != b) or (z % x != c):\n                return False\n                \n        return True\n    except Exception:\n        return False\n\ndef main():\n    if len(sys.argv) != 4:\n        print(False)\n        return\n    input_str = sys.argv[1]\n    output_str = sys.argv[2]\n    reference_output_str = sys.argv[3]\n    print(is_valid_output(input_str, output_str, reference_output_str))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef is_valid_output(input_str, output_str, reference_output_str):\n    try:\n        # \u89e3\u6790\u8f93\u5165\u548c\u8f93\u51fa\n        input_lines = input_str.strip().splitlines()\n        t = int(input_lines[0])\n        test_cases = [list(map(int, line.split())) for line in input_lines[1:]]\n        user_outputs = [list(map(int, line.split())) for line in output_str.strip().splitlines()]\n        \n        # \u68c0\u67e5\u884c\u6570\u662f\u5426\u5339\u914d\n        if len(user_outputs) != t:\n            return False\n            \n        # \u9a8c\u8bc1\u6bcf\u4e2a\u6d4b\u8bd5\u7528\u4f8b\n        for (a, b, c), (x, y, z) in zip(test_cases, user_outputs):\n            # \u68c0\u67e5\u8303\u56f4\u7ea6\u675f\uff1ax, y, z \u5747\u9700\u5728 [1, 10^18] \u8303\u56f4\u5185\n            if not (1 <= x <= 10**18 and 1 <= y <= 10**18 and 1 <= z <= 10**18):\n                return False\n            # \u68c0\u67e5\u9664\u6570\u975e\u96f6\uff08\u907f\u514dZeroDivisionError\uff09\n            if y == 0 or z == 0 or x == 0:\n                return False\n            # \u68c0\u67e5\u4e09\u4e2a\u53d6\u6a21\u6761\u4ef6\n            if (x % y != a) or (y % z != b) or (z % x != c):\n                return False\n                \n        return True\n    except Exception:\n        return False\n\ndef main():\n    if len(sys.argv) != 4:\n        print(False)\n        return\n    input_str = sys.argv[1]\n    output_str = sys.argv[2]\n    reference_output_str = sys.argv[3]\n    print(is_valid_output(input_str, output_str, reference_output_str))\n\nif __name__ == \"__main__\":\n    main()\n"], "type": "stdin", "input_output": "",  "fn_name": null, "time-limit": "10", "memory-limit": "1024"}